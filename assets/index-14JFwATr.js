try{let n=typeof window<"u"?window:typeof global<"u"?global:typeof globalThis<"u"?globalThis:typeof self<"u"?self:{},r=new n.Error().stack;r&&(n._sentryDebugIds=n._sentryDebugIds||{},n._sentryDebugIds[r]="3d20dbc1-db9f-4957-a703-b5c56f0b3742",n._sentryDebugIdIdentifier="sentry-dbid-3d20dbc1-db9f-4957-a703-b5c56f0b3742")}catch{}var C={a:7,c:6,h:1,l:2,m:2,q:4,s:4,t:2,v:1,z:0},B=/([astvzqmhlc])([^astvzqmhlc]*)/gi,H=/-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/gi;function N(n){const r=n.match(H);return r?r.map(Number):[]}function F(n){const r=[],t=String(n).trim();return t[0]!=="M"&&t[0]!=="m"||t.replace(B,(a,s,c)=>{const i=N(c);let o=s.toLowerCase(),u=s;if(o==="m"&&i.length>2&&(r.push([u,...i.splice(0,2)]),o="l",u=u==="m"?"l":"L"),i.length<C[o])return"";for(r.push([u,...i.splice(0,C[o])]);i.length>=C[o]&&i.length&&C[o];)r.push([u,...i.splice(0,C[o])]);return""}),r}function Z(n,r){const t=n.x*Math.cos(r)-n.y*Math.sin(r),a=n.y*Math.cos(r)+n.x*Math.sin(r);n.x=t,n.y=a}function V(n,r,t){n.x+=r,n.y+=t}function _(n,r){n.x*=r,n.y*=r}var E=class ${constructor(r){this.commands=[],r&&r instanceof $?this.commands.push(...r.commands):r&&(this.commands=F(r))}addPath(r){r&&r instanceof $&&this.commands.push(...r.commands)}moveTo(r,t){this.commands.push(["M",r,t])}lineTo(r,t){this.commands.push(["L",r,t])}arc(r,t,a,s,c,i){this.commands.push(["AC",r,t,a,s,c,!!i])}arcTo(r,t,a,s,c){this.commands.push(["AT",r,t,a,s,c])}ellipse(r,t,a,s,c,i,o,u){this.commands.push(["E",r,t,a,s,c,i,o,!!u])}closePath(){this.commands.push(["Z"])}bezierCurveTo(r,t,a,s,c,i){this.commands.push(["C",r,t,a,s,c,i])}quadraticCurveTo(r,t,a,s){this.commands.push(["Q",r,t,a,s])}rect(r,t,a,s){this.commands.push(["R",r,t,a,s])}roundRect(r,t,a,s,c){typeof c>"u"?this.commands.push(["RR",r,t,a,s,0]):this.commands.push(["RR",r,t,a,s,c])}};function w(n,r){let t=0,a=0,s,c,i,o,u,l,g,k,A,M,L,Q,P,p,d,z,q,f,x,I,S,b=null,T=null,m=null,y=null,R=null,v=null;n.beginPath();for(let h=0;h<r.length;++h){f=r[h][0],f!=="S"&&f!=="s"&&f!=="C"&&f!=="c"&&(b=null,T=null),f!=="T"&&f!=="t"&&f!=="Q"&&f!=="q"&&(m=null,y=null);let e;switch(f){case"m":case"M":e=r[h],f==="m"?(t+=e[1],a+=e[2]):(t=e[1],a=e[2]),(f==="M"||!R)&&(R={x:t,y:a}),n.moveTo(t,a);break;case"l":e=r[h],t+=e[1],a+=e[2],n.lineTo(t,a);break;case"L":e=r[h],t=e[1],a=e[2],n.lineTo(t,a);break;case"H":e=r[h],t=e[1],n.lineTo(t,a);break;case"h":e=r[h],t+=e[1],n.lineTo(t,a);break;case"V":e=r[h],a=e[1],n.lineTo(t,a);break;case"v":e=r[h],a+=e[1],n.lineTo(t,a);break;case"a":case"A":if(e=r[h],v===null)throw new Error("This should never happen");f==="a"?(t+=e[6],a+=e[7]):(t=e[6],a=e[7]),p=e[1],d=e[2],g=e[3]*Math.PI/180,i=!!e[4],o=!!e[5],u={x:t,y:a},l={x:(v.x-u.x)/2,y:(v.y-u.y)/2},Z(l,-g),k=l.x*l.x/(p*p)+l.y*l.y/(d*d),k>1&&(k=Math.sqrt(k),p*=k,d*=k),x={x:p*l.y/d,y:-(d*l.x)/p},A=p*p*d*d,M=p*p*l.y*l.y+d*d*l.x*l.x,o!==i?_(x,Math.sqrt((A-M)/M)||0):_(x,-Math.sqrt((A-M)/M)||0),c=Math.atan2((l.y-x.y)/d,(l.x-x.x)/p),s=Math.atan2(-(l.y+x.y)/d,-(l.x+x.x)/p),Z(x,g),V(x,(u.x+v.x)/2,(u.y+v.y)/2),n.save(),n.translate(x.x,x.y),n.rotate(g),n.scale(p,d),n.arc(0,0,1,c,s,!o),n.restore();break;case"C":e=r[h],b=e[3],T=e[4],t=e[5],a=e[6],n.bezierCurveTo(e[1],e[2],b,T,t,a);break;case"c":e=r[h],n.bezierCurveTo(e[1]+t,e[2]+a,e[3]+t,e[4]+a,e[5]+t,e[6]+a),b=e[3]+t,T=e[4]+a,t+=e[5],a+=e[6];break;case"S":e=r[h],(b===null||T===null)&&(b=t,T=a),n.bezierCurveTo(2*t-b,2*a-T,e[1],e[2],e[3],e[4]),b=e[1],T=e[2],t=e[3],a=e[4];break;case"s":e=r[h],(b===null||T===null)&&(b=t,T=a),n.bezierCurveTo(2*t-b,2*a-T,e[1]+t,e[2]+a,e[3]+t,e[4]+a),b=e[1]+t,T=e[2]+a,t+=e[3],a+=e[4];break;case"Q":e=r[h],m=e[1],y=e[2],t=e[3],a=e[4],n.quadraticCurveTo(m,y,t,a);break;case"q":e=r[h],m=e[1]+t,y=e[2]+a,t+=e[3],a+=e[4],n.quadraticCurveTo(m,y,t,a);break;case"T":e=r[h],(m===null||y===null)&&(m=t,y=a),m=2*t-m,y=2*a-y,t=e[1],a=e[2],n.quadraticCurveTo(m,y,t,a);break;case"t":e=r[h],(m===null||y===null)&&(m=t,y=a),m=2*t-m,y=2*a-y,t+=e[1],a+=e[2],n.quadraticCurveTo(m,y,t,a);break;case"z":case"Z":R&&(t=R.x,a=R.y),R=null,n.closePath();break;case"AC":e=r[h],t=e[1],a=e[2],P=e[3],c=e[4],s=e[5],I=e[6],n.arc(t,a,P,c,s,I);break;case"AT":e=r[h],L=e[1],Q=e[2],t=e[3],a=e[4],P=e[5],n.arcTo(L,Q,t,a,P);break;case"E":e=r[h],t=e[1],a=e[2],p=e[3],d=e[4],g=e[5],c=e[6],s=e[7],I=e[8],n.save(),n.translate(t,a),n.rotate(g),n.scale(p,d),n.arc(0,0,1,c,s,I),n.restore();break;case"R":e=r[h],t=e[1],a=e[2],z=e[3],q=e[4],R={x:t,y:a},n.rect(t,a,z,q);break;case"RR":e=r[h],t=e[1],a=e[2],z=e[3],q=e[4],S=e[5],R={x:t,y:a},n.roundRect(t,a,z,q,S);break;default:throw new Error(`Invalid path command: ${f}`)}v?(v.x=t,v.y=a):v={x:t,y:a}}}function D(n,r,t,a,s=0){if(typeof s=="number"&&(s=[s]),Array.isArray(s)){if(s.length===0||s.length>4)throw new RangeError(`Failed to execute 'roundRect' on '${this.constructor.name}': ${s.length} radii provided. Between one and four radii are necessary.`);s.forEach(g=>{if(g<0)throw new RangeError(`Failed to execute 'roundRect' on '${this.constructor.name}': Radius value ${g} is negative.`)})}else return;if(s.length===1&&s[0]===0){this.rect(n,r,t,a);return}const c=Math.min(t,a)/2,i=Math.min(c,s[0]);let o=i,u=i,l=i;s.length===2&&(o=Math.min(c,s[1]),l=o),s.length===3&&(o=Math.min(c,s[1]),l=o,u=Math.min(c,s[2])),s.length===4&&(o=Math.min(c,s[1]),u=Math.min(c,s[2]),l=Math.min(c,s[3])),this.moveTo(n,r+a-l),this.arcTo(n,r,n+i,r,i),this.arcTo(n+t,r,n+t,r+o,o),this.arcTo(n+t,r+a,n+t-u,r+a,u),this.arcTo(n,r+a,n,r+a-l,l),this.closePath()}function j(n){if(!n)return;const r=n.prototype.clip,t=n.prototype.fill,a=n.prototype.stroke,s=n.prototype.isPointInPath;n.prototype.clip=function(...c){if(c[0]instanceof E){const o=c[0],u=c[1]||"nonzero";return w(this,o.commands),r.apply(this,[u])}const i=c[0]||"nonzero";return r.apply(this,[i])},n.prototype.fill=function(...c){if(c[0]instanceof E){const o=c[0],u=c[1]||"nonzero";return w(this,o.commands),t.apply(this,[u])}const i=c[0]||"nonzero";return t.apply(this,[i])},n.prototype.stroke=function(c){c&&w(this,c.commands),a.apply(this)},n.prototype.isPointInPath=function(...c){if(c[0]instanceof E){const i=c[0],o=c[1],u=c[2],l=c[3]||"nonzero";return w(this,i.commands),s.apply(this,[o,u,l])}return s.apply(this,c)}}function G(n){n&&!n.prototype.roundRect&&(n.prototype.roundRect=D)}function J(n){n&&!n.prototype.roundRect&&(n.prototype.roundRect=D)}export{E as Path2D,j as applyPath2DToCanvasRenderingContext,G as applyRoundRectToCanvasRenderingContext2D,J as applyRoundRectToPath2D,w as buildPath,F as parsePath,D as roundRect};
